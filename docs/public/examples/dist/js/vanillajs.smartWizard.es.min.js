var I = (c) => {
  throw TypeError(c);
};
var K = (c, t, e) => t.has(c) || I("Cannot " + e);
var l = (c, t, e) => (K(c, t, "read from private field"), e ? e.call(c) : t.get(c)), d = (c, t, e) => t.has(c) ? I("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(c) : t.set(c, e);
var i = (c, t, e) => (K(c, t, "access private method"), e);
var R, s, C, F, m, J, T, Q, X, S, D, k, P, A, q, Y, Z, L, f, g, b, N, $, _, H, B, y, z, tt, E, st, et, it, nt, v, V, W, ot, w;
const j = class j {
  constructor(t, e) {
    d(this, s);
    d(this, S, (t) => {
      this.options.debug && console.debug("Click on step " + t.currentTarget + "..."), t.preventDefault(), this.options.anchor.enableNavigation === !0 && i(this, s, N).call(this, t.currentTarget) && i(this, s, g).call(this, Array.from(this.steps).indexOf(t.currentTarget));
    });
    d(this, D, (t) => {
      this.options.debug && console.debug("Click on element..."), t.target.classList.contains(this.options.style.btnNextCss) ? (t.preventDefault(), i(this, s, f).call(this, "next")) : t.target.classList.contains(this.options.style.btnPrevCss) && (t.preventDefault(), i(this, s, f).call(this, "prev"));
    });
    d(this, k, (t) => {
      this.options.debug && console.debug("Keyup triggered..."), i(this, s, nt).call(this, t);
    });
    d(this, P, (t) => {
      if (this.options.debug && console.debug("hashchange triggered..."), this.options.backButtonSupport !== !0)
        return;
      const e = i(this, s, W).call(this);
      e !== !1 && i(this, s, N).call(this, this.steps[e]) && (t.preventDefault(), i(this, s, g).call(this, e));
    });
    d(this, A, () => {
      this.options.debug && console.debug("Resize triggered..."), i(this, s, E).call(this, this.current_index);
    });
    d(this, q, () => (this.options.debug && console.debug("Submit triggered..."), i(this, s, m).call(this)));
    const n = {
      debug: !1,
      initAtCreated: !0,
      selected: 0,
      theme: "basic",
      justified: !0,
      requiredField: {
        active: !0,
        checkOnSubmitForm: !0,
        submitEvent: !1,
        controls: "input, textarea, select",
        classInvalid: "is-invalid",
        functionToValidate: null
      },
      autoAdjustHeight: !0,
      backButtonSupport: !0,
      enableUrlHash: !0,
      transition: {
        animation: "fade",
        speed: 400,
        easing: "",
        prefixCss: "",
        fwdShowCss: "",
        fwdHideCss: "",
        bckShowCss: "",
        bckHideCss: ""
      },
      toolbar: {
        position: "bottom",
        showNextButton: !0,
        showPreviousButton: !0,
        extraHtml: ""
      },
      anchor: {
        enableNavigation: !0,
        enableNavigationAlways: !1,
        enableDoneState: !0,
        markPreviousStepsAsDone: !0,
        unDoneOnBackNavigation: !1,
        enableDoneStateNavigation: !0
      },
      keyboard: {
        keyNavigation: !0,
        keyLeft: [37],
        keyRight: [39]
      },
      lang: {
        next: "Next",
        previous: "Previous"
      },
      style: {
        mainCss: "sw",
        navCss: "nav",
        navLinkCss: "nav-link",
        contentCss: "sw-content",
        contentPanelCss: "sw-panel",
        themePrefixCss: "sw-theme-",
        anchorDefaultCss: "sw-default",
        anchorDoneCss: "sw-done",
        anchorActiveCss: "sw-active",
        anchorDisabledCss: "sw-disabled",
        anchorHiddenCss: "sw-hidden",
        anchorErrorCss: "sw-error",
        anchorWarningCss: "sw-warning",
        justifiedCss: "sw-justified",
        btnCss: "sw-btn",
        btnNextCss: "sw-btn-next",
        btnPrevCss: "sw-btn-prev",
        loaderCss: "sw-loading",
        progressCss: "progress",
        progressBarCss: "progress-bar",
        toolbarCss: "toolbar",
        toolbarPrefixCss: "toolbar-"
      },
      disabledSteps: [],
      errorSteps: [],
      warningSteps: [],
      hiddenSteps: [],
      getContent: null
    }, o = (r, a) => {
      if (typeof r == "object" && r !== null && typeof a == "object" && a !== null) {
        const h = { ...r };
        for (const p in a)
          Object.prototype.hasOwnProperty.call(a, p) && (h[p] = o(h[p], a[p]));
        return h;
      }
      return a;
    };
    this.options = o(n, e), this.element = typeof t == "string" ? document.querySelector(t) : t, this.nav = i(this, s, T).call(this, `.${this.options.style.navCss}`), this.container = i(this, s, T).call(this, `.${this.options.style.contentCss}`), this.steps = Array.from(this.nav.querySelectorAll(`.${this.options.style.navLinkCss}`)), this.pages = Array.from(this.container.querySelectorAll(`.${this.options.style.contentPanelCss}`)), this.progressbar = this.element.querySelector(`.${this.options.style.progressCss}`), this.dir = i(this, s, Q).call(this), this.current_index = -1, this.is_init = !1, this.searchFormClosest = null, this.options.initAtCreated && i(this, s, C).call(this).then(() => {
      i(this, s, F).call(this);
    });
  }
  // Public methods
  goToStep(t, e) {
    e = e !== !1, !(e !== !0 && !i(this, s, N).call(this, this.steps[t])) && (e === !0 && t > 0 && this.options.anchor.enableDoneState && this.options.anchor.markPreviousStepsAsDone && this.steps.slice(0, t).forEach((n) => n.classList.add(this.options.style.anchorDoneCss)), i(this, s, g).call(this, t));
  }
  next() {
    i(this, s, f).call(this, "next");
  }
  prev() {
    i(this, s, f).call(this, "prev");
  }
  reset() {
    this.steps.forEach((t) => t.classList.remove(
      this.options.style.anchorDoneCss,
      this.options.style.anchorActiveCss,
      this.options.style.anchorErrorCss,
      this.options.style.anchorWarningCss
    )), i(this, s, V).call(this, "#"), i(this, s, C).call(this).then(() => {
      i(this, s, F).call(this);
    });
  }
  setState(t, e) {
    i(this, s, w).call(this, t, e, !0);
  }
  unsetState(t, e) {
    i(this, s, w).call(this, t, e, !1);
  }
  unsetErrors(t) {
    i(this, s, w).call(this, null, "error", !1, t);
  }
  setOptions(t) {
    this.options = { ...this.options, ...t }, i(this, s, C).call(this).then();
  }
  getOptions() {
    return this.options;
  }
  getStepInfo() {
    return {
      currentStep: this.current_index !== null ? this.current_index : 0,
      totalSteps: this.steps ? this.steps.length : 0
    };
  }
  loader(t) {
    this.element.classList.toggle(this.options.style.loaderCss, t === "show");
  }
  fixHeight() {
    i(this, s, E).call(this, this.current_index);
  }
  init() {
    i(this, s, C).call(this).then(() => {
      i(this, s, F).call(this);
    });
  }
  checkStepRequired(t) {
    return i(this, s, m).call(this, !0, t);
  }
  checkFormRequireds() {
    return i(this, s, m).call(this);
  }
  destroy() {
    this.steps.forEach((t) => {
      t.removeEventListener("click", l(this, S));
    }), this.element.removeEventListener("click", l(this, D)), document.removeEventListener("keyup", l(this, k)), window.removeEventListener("hashchange", l(this, P)), window.removeEventListener("resize", l(this, A)), this.searchFormClosest && this.searchFormClosest.removeEventListener("submit", l(this, q)), this.options.debug && console.log("Events destroyed. The object is no longer active.");
  }
};
R = new WeakMap(), s = new WeakSet(), C = async function() {
  return this.options.debug && console.debug("Triggered init() method..."), i(this, s, X).call(this), i(this, s, Z).call(this), this.is_init || (i(this, s, Y).call(this), this.is_init = !0, i(this, s, v).call(this, "initialized")), !0;
}, F = function() {
  this.options.debug && console.debug("Triggered load() method..."), this.pages.forEach((n) => n.style.display = "none"), this.steps.forEach((n) => n.classList.remove(this.options.style.anchorDoneCss, this.options.style.anchorActiveCss)), this.current_index = -1;
  let t = i(this, s, W).call(this);
  t = t !== !1 ? t : this.options.selected;
  const e = i(this, s, b).call(this, t - 1, "forward");
  t = e === null && t > 0 ? i(this, s, b).call(this, -1, "forward") : e, t > 0 && this.options.anchor.enableDoneState && this.options.anchor.markPreviousStepsAsDone && this.steps.slice(0, t).forEach((n) => n.classList.add(this.options.style.anchorDoneCss)), i(this, s, g).call(this, t), i(this, s, v).call(this, "loaded");
}, m = function(t = !1, e = null) {
  if (this.options.requiredField.active) {
    let n = this.element.querySelectorAll(this.options.requiredField.controls);
    if (t) {
      if (this.current_index < 0) return !1;
      n = i(this, s, y).call(this, this.current_index).querySelectorAll(this.options.requiredField.controls);
    }
    if (n.length > 0) {
      let o = [];
      if (n.forEach((r) => {
        (r.required || r.classList.contains("required")) && (typeof this.options.requiredField.functionToValidate == "function" ? this.options.requiredField.functionToValidate(r) && o.push(r) : (r.value === "" || r.value === void 0 || r.value === null) && o.push(r));
      }), o.length > 0) {
        this.options.requiredField.submitEvent ? i(this, s, v).call(this, "requiredErrors", o) : o.forEach((a) => {
          a.classList.add(this.options.requiredField.classInvalid);
        });
        let r = i(this, s, J).call(this, o[0]);
        return r >= 0 && (i(this, s, w).call(this, null, "error", !0, r), e !== r && i(this, s, g).call(this, r)), !0;
      }
    }
  }
  return !1;
}, J = function(t) {
  for (let e = 0; e < this.pages.length; e++)
    if (this.pages[e].contains(t))
      return e;
  return -1;
}, T = function(t) {
  this.options.debug && console.debug("Triggered getFirstDescendant() method...");
  let e = this.element.querySelector(t);
  return e || (i(this, s, ot).call(this, `Elemento no encontrado: ${t}`), null);
}, Q = function() {
  this.options.debug && console.debug("Triggered getDir() method...");
  let t = this.element.getAttribute("dir");
  return t || (t = document.documentElement.getAttribute("dir") || "ltr", this.element.setAttribute("dir", t)), t;
}, X = function() {
  this.options.debug && console.debug("Triggered setElements() method..."), this.element.className = "", this.element.classList.add(this.options.style.mainCss, this.options.style.themePrefixCss + this.options.theme), this.element.classList.toggle(this.options.style.justifiedCss, this.options.justified), (this.options.anchor.enableNavigationAlways !== !0 || this.options.anchor.enableNavigation !== !0) && this.steps.forEach((t) => t.classList.add(this.options.style.anchorDefaultCss)), this.options.disabledSteps.forEach((t) => this.steps[t].classList.add(this.options.style.anchorDisabledCss)), this.options.errorSteps.forEach((t) => this.steps[t].classList.add(this.options.style.anchorErrorCss)), this.options.warningSteps.forEach((t) => this.steps[t].classList.add(this.options.style.anchorWarningCss)), this.options.hiddenSteps.forEach((t) => this.steps[t].classList.add(this.options.style.anchorHiddenCss));
}, S = new WeakMap(), D = new WeakMap(), k = new WeakMap(), P = new WeakMap(), A = new WeakMap(), q = new WeakMap(), Y = function() {
  this.options.debug && console.debug("Triggered setEvents() method..."), this.steps.forEach((t) => {
    t.addEventListener("click", l(this, S));
  }), this.element.addEventListener("click", l(this, D)), document.addEventListener("keyup", l(this, k)), window.addEventListener("hashchange", l(this, P)), window.addEventListener("resize", l(this, A)), this.options.requiredField.checkOnSubmitForm && (this.searchFormClosest = this.element.closest("form"), this.searchFormClosest && this.searchFormClosest.addEventListener("submit", l(this, q)));
}, Z = function() {
  switch (this.options.debug && console.debug("Triggered setToolbar() method... type " + this.options.toolbar.position), this.element.querySelectorAll(".sw-toolbar-elm").forEach((t) => t.remove()), this.options.toolbar.position) {
    case "both":
      this.container.before(i(this, s, L).call(this, "top")), this.container.after(i(this, s, L).call(this, "bottom"));
      break;
    case "top":
      this.container.before(i(this, s, L).call(this, "top"));
      break;
    case "bottom":
      this.container.after(i(this, s, L).call(this, "bottom"));
      break;
  }
}, L = function(t) {
  const e = document.createElement("div");
  e.classList.add("sw-toolbar-elm", this.options.style.toolbarCss, this.options.style.toolbarPrefixCss + t), e.setAttribute("role", "toolbar");
  const n = this.options.toolbar.showNextButton !== !1 ? Object.assign(document.createElement("button"), {
    textContent: this.options.lang.next,
    className: `btn ${this.options.style.btnNextCss} ${this.options.style.btnCss}`,
    type: "button"
  }) : null, o = this.options.toolbar.showPreviousButton !== !1 ? Object.assign(document.createElement("button"), {
    textContent: this.options.lang.previous,
    className: `btn ${this.options.style.btnPrevCss} ${this.options.style.btnCss}`,
    type: "button"
  }) : null;
  return o && e.appendChild(o), n && e.appendChild(n), this.options.toolbar.extraHtml && (e.innerHTML += this.options.toolbar.extraHtml), e;
}, f = function(t) {
  i(this, s, g).call(this, i(this, s, b).call(this, this.current_index, t));
}, g = function(t) {
  if (this.options.debug && console.debug("Triggered showStep() method..."), i(this, s, m).call(this, !0, t))
    return !1;
  {
    if (t === -1 || t === null || t === this.current_index || !this.steps[t] || !i(this, s, $).call(this, this.steps[t]))
      return !1;
    const e = i(this, s, _).call(this, t);
    if (this.current_index !== -1 && !i(this, s, v).call(this, "leaveStep", {
      stepAnchor: i(this, s, B).call(this, this.current_index),
      stepIndex: this.current_index,
      stepDirection: e
    }))
      return !1;
    i(this, s, z).call(this, t, () => {
      const n = i(this, s, B).call(this, t);
      i(this, s, V).call(this, n.getAttribute("href")), i(this, s, st).call(this, t);
      const o = i(this, s, y).call(this, this.current_index), r = i(this, s, y).call(this, t);
      i(this, s, tt).call(this, r, o, e, () => {
        i(this, s, E).call(this, t), i(this, s, v).call(this, "showStep", {
          selStep: n,
          idx: t,
          stepDirection: e,
          stepPosition: i(this, s, H).call(this, t)
        });
      }), this.current_index = t, i(this, s, et).call(this, t), i(this, s, it).call(this, t);
    });
  }
}, b = function(t, e) {
  let n = null, o;
  e === "prev" ? o = this.steps.slice(0, t).reverse() : o = this.steps.slice(t + 1);
  for (let r = 0; r < o.length; r++) {
    const a = o[r];
    if (i(this, s, $).call(this, a)) {
      n = e === "prev" ? t - (r + 1) : r + t + 1;
      break;
    }
  }
  return n;
}, N = function(t) {
  if (!i(this, s, $).call(this, t))
    return !1;
  const e = t.classList.contains(this.options.style.anchorDoneCss);
  return this.options.anchor.enableDoneStateNavigation === !1 && e ? !1 : !(this.options.anchor.enableNavigationAlways === !1 && !e);
}, $ = function(t) {
  return !t.classList.contains(this.options.style.anchorDisabledCss) && !t.classList.contains(this.options.style.anchorHiddenCss);
}, _ = function(t) {
  return this.current_index < t ? "forward" : "backward";
}, H = function(t) {
  return t === 0 ? "first" : t === this.steps.length - 1 ? "last" : "middle";
}, B = function(t) {
  return t === null || t === -1 ? null : this.steps[t];
}, y = function(t) {
  return t === null || t === -1 ? null : this.pages[t];
}, z = function(t, e) {
  if (typeof this.options.getContent != "function") {
    e();
    return;
  }
  const n = i(this, s, y).call(this, t);
  if (!n) {
    e();
    return;
  }
  const o = i(this, s, _).call(this, t), r = i(this, s, H).call(this, t), a = i(this, s, B).call(this, t);
  this.options.getContent(t, o, r, a, (h) => {
    h && (n.innerHTML = h), e();
  });
}, tt = function(t, e, n, o) {
  const r = l(j, R)[this.options.transition.animation];
  this.options.debug && console.debug("Triggered transit() method... " + this.options.transition.animation), typeof r == "function" ? r(t, e, n, this, (a) => {
    i(this, s, E).call(this, this.current_index), this.options.debug && console.debug("Triggered end animation method... " + this.options.transition.animation), a === !1 && (e && (e.style.display = "none"), t.style.display = ""), o();
  }) : (e && (e.style.display = "none"), t.style.display = "", o());
}, E = function(t) {
  if (this.options.autoAdjustHeight === !1) return;
  const e = i(this, s, y).call(this, t).offsetHeight;
  this.options.debug && console.debug("Fixed height triggered (Page: " + t + ") ... " + e), e > 0 ? this.container.style.height = `${e}px` : this.container.style.height = "auto";
}, st = function(t) {
  if (this.current_index !== null && this.current_index >= 0) {
    const e = this.steps[this.current_index];
    e.classList.remove(this.options.style.anchorActiveCss), this.options.anchor.enableDoneState !== !1 && (e.classList.add(this.options.style.anchorDoneCss), this.options.anchor.unDoneOnBackNavigation !== !1 && i(this, s, _).call(this, t) === "backward" && e.classList.remove(this.options.style.anchorDoneCss));
  }
  this.steps[t].classList.remove(this.options.style.anchorDoneCss), this.steps[t].classList.add(this.options.style.anchorActiveCss);
}, et = function(t) {
  const e = this.element.querySelector(`.${this.options.style.btnNextCss}`), n = this.element.querySelector(`.${this.options.style.btnPrevCss}`);
  e && e.classList.remove(this.options.style.anchorDisabledCss), n && n.classList.remove(this.options.style.anchorDisabledCss);
  const o = i(this, s, H).call(this, t);
  if (o === "first" || o === "last") {
    const r = o === "first" ? n : e;
    r && r.classList.add(this.options.style.anchorDisabledCss);
  } else
    i(this, s, b).call(this, t, "next") === null && e && e.classList.add(this.options.style.anchorDisabledCss), i(this, s, b).call(this, t, "prev") === null && n && n.classList.add(this.options.style.anchorDisabledCss);
}, it = function(t) {
  const e = this.nav.offsetWidth, n = e / this.steps.length * (t + 1) / e * 100;
  document.documentElement.style.setProperty("--sw-progress-width", `${n}%`), this.progressbar && (this.progressbar.querySelector(`.${this.options.style.progressBarCss}`).style.width = `${n}%`);
}, nt = function(t) {
  this.options.keyboard.keyNavigation && (this.options.keyboard.keyLeft.includes(t.which) ? (i(this, s, f).call(this, "prev"), t.preventDefault()) : this.options.keyboard.keyRight.includes(t.which) && (i(this, s, f).call(this, "next"), t.preventDefault()));
}, v = function(t, e) {
  this.options.debug && console.debug("Triggered triggerEvent() method... " + t), e = e || {}, e.wizard = this;
  const n = new CustomEvent(t, {
    detail: e,
    bubbles: !0,
    cancelable: !0
  });
  return this.element.dispatchEvent(n), !n.defaultPrevented;
}, V = function(t) {
  this.options.enableUrlHash && window.location.hash !== t && history.pushState(null, null, t);
}, W = function() {
  if (this.options.enableUrlHash && window.location.hash.length > 0) {
    const t = this.nav.querySelector(`a[href*='${window.location.hash}']`);
    if (t)
      return this.steps.indexOf(t);
  }
  return !1;
}, ot = function(t) {
  console.error(t);
}, w = function(t = null, e, n, o = null) {
  const a = {
    default: this.options.style.anchorDefaultCss,
    active: this.options.style.anchorActiveCss,
    done: this.options.style.anchorDoneCss,
    disable: this.options.style.anchorDisabledCss,
    hidden: this.options.style.anchorHiddenCss,
    error: this.options.style.anchorErrorCss,
    warning: this.options.style.anchorWarningCss
  }[e];
  if (a)
    if (o !== null) {
      const h = this.steps[o] || null;
      h && (n ? h.classList.add(a) : h.classList.remove(a));
    } else t && t.forEach((h) => {
      const p = this.steps[h];
      n ? p.classList.add(a) : p.classList.remove(a);
    });
}, d(j, R, {
  fade: (t, e, n, o, r) => {
    (e ? new Promise((h) => {
      e.style.transition = `opacity ${o.options.transition.speed / 1e3}s ease`, e.style.opacity = "0", e.addEventListener("transitionend", () => {
        e.style.display = "none", e.style.transition = "", h();
      }, { once: !0 });
    }) : Promise.resolve()).then(() => {
      t.style.transition = `opacity ${o.options.transition.speed / 1e3}s ease`, t.style.opacity = "0", t.style.display = "", setTimeout(() => {
        t.style.opacity = "1", t.addEventListener("transitionend", () => {
          t.style.transition = "", r();
        }, { once: !0 });
      }, 50);
    });
  },
  css: (t, e, n, o, r) => {
    const a = (u, x, O) => {
      if (!x) {
        O();
        return;
      }
      const U = () => {
        u.classList.remove(x), u.removeEventListener("animationend", U), u.removeEventListener("animationcancel", M), O();
      }, M = () => {
        u.classList.remove(x), u.removeEventListener("animationend", U), u.removeEventListener("animationcancel", M), O("cancel");
      };
      u.classList.add(x), u.addEventListener("animationend", U), u.addEventListener("animationcancel", M);
    }, h = `${o.options.transition.prefixCss} ${n === "backward" ? o.options.transition.bckShowCss : o.options.transition.fwdShowCss}`, p = `${o.options.transition.prefixCss} ${n === "backward" ? o.options.transition.bckHideCss : o.options.transition.fwdHideCss}`;
    e ? a(e, p, () => {
      e.style.display = "none", t.style.display = "", a(t, h, () => {
        r();
      });
    }) : (t.style.display = "", a(t, h, () => {
      r();
    }));
  }
});
let G = j;
export {
  G as default
};
